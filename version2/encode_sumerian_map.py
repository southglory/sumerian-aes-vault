import pickle, zlib, base64

# ìˆ˜ë©”ë¥´ì–´ ë³€í™˜ ë§¤í•‘ (ì•ŒíŒŒë²³ + ìˆ«ì + íŠ¹ìˆ˜ë¬¸ì â†’ ìˆ˜ë©”ë¥´ì–´)
sumerian_cipher_map = {
    # ì•ŒíŒŒë²³ ì†Œë¬¸ì
    "a": "ğ’€€",
    "b": "ğ’€",
    "c": "ğ’",
    "d": "ğ’•",
    "e": "ğ’‚Š",
    "f": "ğ’† ",
    "g": "ğ’‚…",
    "h": "ğ’„­",
    "i": "ğ’„¿",
    "j": "ğ’‹¡",
    "k": "ğ’†ª",
    "l": "ğ’‡·",
    "m": "ğ’ˆ¬",
    "n": "ğ’‰ˆ",
    "o": "ğ’Œ·",
    "p": "ğ’‰¿",
    "q": "ğ’ª",
    "r": "ğ’Š",
    "s": "ğ’Š­",
    "t": "ğ’‹¾",
    "u": "ğ’Œ‹",
    "v": "ğ’…ˆ",
    "w": "ğ’‚—",
    "x": "ğ’Š",
    "y": "ğ’…†",
    "z": "ğ’£",
    # ìˆ«ì
    "0": "ğ’€¹",
    "1": "ğ’¹",
    "2": "ğ’€»",
    "3": "ğ’€¼",
    "4": "ğ’Œ",
    "5": "ğ’‰½",
    "6": "ğ’–",
    "7": "ğ’—",
    "8": "ğ’˜",
    "9": "ğ’™",
    # Base64 íŠ¹ìˆ˜ë¬¸ì
    "+": "ğ’ƒ»",
    "/": "ğ’º",
    "=": "ğ’ˆ¦",
    # ê³µë°± ë° ì¶”ê°€ íŠ¹ìˆ˜ë¬¸ì
    " ": "ğ’Œƒ",
    ".": "ğ’‡",
    ",": "ğ’„‘",
    "!": "ğ’„ ",
    "?": "ğ’…",
    "@": "ğ’€­",
    "#": "ğ’‚”",
    "$": "ğ’Œ¨",
    "%": "ğ’Š¬",
    "^": "ğ’…–",
    "&": "ğ’€",
    "*": "ğ’€¯",
    "(": "ğ’",
    ")": "ğ’",
    "-": "ğ’²",
    "_": "ğ’€",
    "[": "ğ’Œ",
    "]": "ğ’ŒŒ",
    "{": "ğ’¢",
    "}": "ğ’¤",
    "|": "ğ’Œ’",
    "\\": "ğ’¦",
    ":": "ğ’Œ“",
    ";": "ğ’Œ‡",
    '"': "ğ’‹°",
    "'": "ğ’‹«",
    "<": "ğ’‰º",
    ">": "ğ’Š’",
    "`": "ğ’‹›",
    "~": "ğ’€Š",
}

# ì§ë ¬í™”(pickle), ì••ì¶•(zlib), ì¸ì½”ë”©(base64)
encoded = base64.b64encode(zlib.compress(pickle.dumps(sumerian_cipher_map)))
print(encoded.decode())  # ë³µì‚¬í•´ì„œ ì½”ë“œì— ë¶™ì´ë©´ ë¨

# encodedë¥¼ í…ìŠ¤íŠ¸ì— ìƒì„±
with open("./version2/sumerian_cipher_map.txt", "w", encoding="utf-8") as f:
    f.write(encoded.decode())


# ë³µì› í•¨ìˆ˜
def load_mapping():
    return pickle.loads(zlib.decompress(base64.b64decode(encoded)))


if __name__ == "__main__":
    print(load_mapping())
